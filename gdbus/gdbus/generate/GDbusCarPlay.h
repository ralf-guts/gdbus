/*
 * This file is generated by gdbus-codegen, do not modify it.
 *
 * The license of this code is the same as for the D-Bus interface description
 * it was derived from. Note that it links to GLib, so must comply with the
 * LGPL linking clauses.
 */

#ifndef __GDBUSCARPLAY_H__
#define __GDBUSCARPLAY_H__

#include <gio/gio.h>

G_BEGIN_DECLS


/* ------------------------------------------------------------------------ */
/* Declarations for com.hsae.airplay */

#define TYPE_AIRPLAY (airplay_get_type ())
#define AIRPLAY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_AIRPLAY, Airplay))
#define IS_AIRPLAY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_AIRPLAY))
#define AIRPLAY_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_AIRPLAY, AirplayIface))

struct _Airplay;
typedef struct _Airplay Airplay;
typedef struct _AirplayIface AirplayIface;

struct _AirplayIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_send_change_app_state) (
    Airplay *object,
    GDBusMethodInvocation *invocation,
    gint arg_phone,
    gint arg_speech,
    gint arg_turnByTurn);

  gboolean (*handle_send_change_modes) (
    Airplay *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_screenBorrowId,
    gint arg_screenType,
    gint arg_screenPriority,
    gint arg_screenTake,
    gint arg_screenBorrow,
    const gchar *arg_audioBorrowId,
    gint arg_audioType,
    gint arg_audioPriority,
    gint arg_audioTake,
    gint arg_audioBorrow,
    gint arg_phone,
    gint arg_speech,
    gint arg_turnByTurn);

  gboolean (*handle_send_change_resource_mode) (
    Airplay *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_borrowID,
    gint arg_resourceId,
    gint arg_type,
    gint arg_priority,
    gint arg_takeConstraint,
    gint arg_borrowConstraint);

  gboolean (*handle_send_request_siri_action) (
    Airplay *object,
    GDBusMethodInvocation *invocation,
    gint arg_action);

  gboolean (*handle_send_request_ui) (
    Airplay *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_send_set_night_mode) (
    Airplay *object,
    GDBusMethodInvocation *invocation,
    gint arg_nightMode);

  gboolean (*handle_send_touch_screen_update) (
    Airplay *object,
    GDBusMethodInvocation *invocation,
    gboolean arg_press,
    guint16 arg_x,
    guint16 arg_y);

  void (*handle_audio_stream_start) (
    Airplay *object);

  void (*handle_audio_stream_stop) (
    Airplay *object);

  void (*handle_screen_stream_start) (
    Airplay *object);

  void (*handle_screen_stream_stop) (
    Airplay *object);

  void (*handle_session_control_disable_bluetooth) (
    Airplay *object,
    const gchar *arg_address);

  void (*handle_session_created) (
    Airplay *object);

  void (*handle_session_duck_audio) (
    Airplay *object,
    gdouble arg_durationSecs,
    gdouble arg_volume);

  void (*handle_session_finalized) (
    Airplay *object);

  void (*handle_session_modes_changed) (
    Airplay *object,
    gint arg_screen,
    gint arg_permScreen,
    gint arg_audio,
    gint arg_permAudio,
    gint arg_speechEntity,
    gint arg_speechMode,
    gint arg_phoneCall,
    gint arg_turnByTurn);

  void (*handle_session_request_ui) (
    Airplay *object);

  void (*handle_session_started) (
    Airplay *object);

  void (*handle_session_unduck_audio) (
    Airplay *object,
    gdouble arg_durationSecs,
    gdouble arg_volume);

};

GType airplay_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *airplay_interface_info (void);
guint airplay_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void airplay_complete_send_change_modes (
    Airplay *object,
    GDBusMethodInvocation *invocation);

void airplay_complete_send_change_resource_mode (
    Airplay *object,
    GDBusMethodInvocation *invocation);

void airplay_complete_send_change_app_state (
    Airplay *object,
    GDBusMethodInvocation *invocation);

void airplay_complete_send_request_ui (
    Airplay *object,
    GDBusMethodInvocation *invocation);

void airplay_complete_send_set_night_mode (
    Airplay *object,
    GDBusMethodInvocation *invocation);

void airplay_complete_send_request_siri_action (
    Airplay *object,
    GDBusMethodInvocation *invocation);

void airplay_complete_send_touch_screen_update (
    Airplay *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void airplay_emit_handle_session_created (
    Airplay *object);

void airplay_emit_handle_session_started (
    Airplay *object);

void airplay_emit_handle_session_finalized (
    Airplay *object);

void airplay_emit_handle_session_modes_changed (
    Airplay *object,
    gint arg_screen,
    gint arg_permScreen,
    gint arg_audio,
    gint arg_permAudio,
    gint arg_speechEntity,
    gint arg_speechMode,
    gint arg_phoneCall,
    gint arg_turnByTurn);

void airplay_emit_handle_session_request_ui (
    Airplay *object);

void airplay_emit_handle_session_duck_audio (
    Airplay *object,
    gdouble arg_durationSecs,
    gdouble arg_volume);

void airplay_emit_handle_session_unduck_audio (
    Airplay *object,
    gdouble arg_durationSecs,
    gdouble arg_volume);

void airplay_emit_handle_session_control_disable_bluetooth (
    Airplay *object,
    const gchar *arg_address);

void airplay_emit_handle_screen_stream_start (
    Airplay *object);

void airplay_emit_handle_screen_stream_stop (
    Airplay *object);

void airplay_emit_handle_audio_stream_start (
    Airplay *object);

void airplay_emit_handle_audio_stream_stop (
    Airplay *object);



/* D-Bus method calls: */
void airplay_call_send_change_modes (
    Airplay *proxy,
    const gchar *arg_screenBorrowId,
    gint arg_screenType,
    gint arg_screenPriority,
    gint arg_screenTake,
    gint arg_screenBorrow,
    const gchar *arg_audioBorrowId,
    gint arg_audioType,
    gint arg_audioPriority,
    gint arg_audioTake,
    gint arg_audioBorrow,
    gint arg_phone,
    gint arg_speech,
    gint arg_turnByTurn,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean airplay_call_send_change_modes_finish (
    Airplay *proxy,
    GAsyncResult *res,
    GError **error);

gboolean airplay_call_send_change_modes_sync (
    Airplay *proxy,
    const gchar *arg_screenBorrowId,
    gint arg_screenType,
    gint arg_screenPriority,
    gint arg_screenTake,
    gint arg_screenBorrow,
    const gchar *arg_audioBorrowId,
    gint arg_audioType,
    gint arg_audioPriority,
    gint arg_audioTake,
    gint arg_audioBorrow,
    gint arg_phone,
    gint arg_speech,
    gint arg_turnByTurn,
    GCancellable *cancellable,
    GError **error);

void airplay_call_send_change_resource_mode (
    Airplay *proxy,
    const gchar *arg_borrowID,
    gint arg_resourceId,
    gint arg_type,
    gint arg_priority,
    gint arg_takeConstraint,
    gint arg_borrowConstraint,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean airplay_call_send_change_resource_mode_finish (
    Airplay *proxy,
    GAsyncResult *res,
    GError **error);

gboolean airplay_call_send_change_resource_mode_sync (
    Airplay *proxy,
    const gchar *arg_borrowID,
    gint arg_resourceId,
    gint arg_type,
    gint arg_priority,
    gint arg_takeConstraint,
    gint arg_borrowConstraint,
    GCancellable *cancellable,
    GError **error);

void airplay_call_send_change_app_state (
    Airplay *proxy,
    gint arg_phone,
    gint arg_speech,
    gint arg_turnByTurn,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean airplay_call_send_change_app_state_finish (
    Airplay *proxy,
    GAsyncResult *res,
    GError **error);

gboolean airplay_call_send_change_app_state_sync (
    Airplay *proxy,
    gint arg_phone,
    gint arg_speech,
    gint arg_turnByTurn,
    GCancellable *cancellable,
    GError **error);

void airplay_call_send_request_ui (
    Airplay *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean airplay_call_send_request_ui_finish (
    Airplay *proxy,
    GAsyncResult *res,
    GError **error);

gboolean airplay_call_send_request_ui_sync (
    Airplay *proxy,
    GCancellable *cancellable,
    GError **error);

void airplay_call_send_set_night_mode (
    Airplay *proxy,
    gint arg_nightMode,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean airplay_call_send_set_night_mode_finish (
    Airplay *proxy,
    GAsyncResult *res,
    GError **error);

gboolean airplay_call_send_set_night_mode_sync (
    Airplay *proxy,
    gint arg_nightMode,
    GCancellable *cancellable,
    GError **error);

void airplay_call_send_request_siri_action (
    Airplay *proxy,
    gint arg_action,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean airplay_call_send_request_siri_action_finish (
    Airplay *proxy,
    GAsyncResult *res,
    GError **error);

gboolean airplay_call_send_request_siri_action_sync (
    Airplay *proxy,
    gint arg_action,
    GCancellable *cancellable,
    GError **error);

void airplay_call_send_touch_screen_update (
    Airplay *proxy,
    gboolean arg_press,
    guint16 arg_x,
    guint16 arg_y,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean airplay_call_send_touch_screen_update_finish (
    Airplay *proxy,
    GAsyncResult *res,
    GError **error);

gboolean airplay_call_send_touch_screen_update_sync (
    Airplay *proxy,
    gboolean arg_press,
    guint16 arg_x,
    guint16 arg_y,
    GCancellable *cancellable,
    GError **error);



/* ---- */

#define TYPE_AIRPLAY_PROXY (airplay_proxy_get_type ())
#define AIRPLAY_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_AIRPLAY_PROXY, AirplayProxy))
#define AIRPLAY_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_AIRPLAY_PROXY, AirplayProxyClass))
#define AIRPLAY_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_AIRPLAY_PROXY, AirplayProxyClass))
#define IS_AIRPLAY_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_AIRPLAY_PROXY))
#define IS_AIRPLAY_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_AIRPLAY_PROXY))

typedef struct _AirplayProxy AirplayProxy;
typedef struct _AirplayProxyClass AirplayProxyClass;
typedef struct _AirplayProxyPrivate AirplayProxyPrivate;

struct _AirplayProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  AirplayProxyPrivate *priv;
};

struct _AirplayProxyClass
{
  GDBusProxyClass parent_class;
};

GType airplay_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (AirplayProxy, g_object_unref)
#endif

void airplay_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Airplay *airplay_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
Airplay *airplay_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void airplay_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Airplay *airplay_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
Airplay *airplay_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_AIRPLAY_SKELETON (airplay_skeleton_get_type ())
#define AIRPLAY_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_AIRPLAY_SKELETON, AirplaySkeleton))
#define AIRPLAY_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_AIRPLAY_SKELETON, AirplaySkeletonClass))
#define AIRPLAY_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_AIRPLAY_SKELETON, AirplaySkeletonClass))
#define IS_AIRPLAY_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_AIRPLAY_SKELETON))
#define IS_AIRPLAY_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_AIRPLAY_SKELETON))

typedef struct _AirplaySkeleton AirplaySkeleton;
typedef struct _AirplaySkeletonClass AirplaySkeletonClass;
typedef struct _AirplaySkeletonPrivate AirplaySkeletonPrivate;

struct _AirplaySkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  AirplaySkeletonPrivate *priv;
};

struct _AirplaySkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType airplay_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (AirplaySkeleton, g_object_unref)
#endif

Airplay *airplay_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for com.hsae.iap2 */

#define TYPE_IAP2 (iap2_get_type ())
#define IAP2(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_IAP2, Iap2))
#define IS_IAP2(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_IAP2))
#define IAP2_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_IAP2, Iap2Iface))

struct _Iap2;
typedef struct _Iap2 Iap2;
typedef struct _Iap2Iface Iap2Iface;

struct _Iap2Iface
{
  GTypeInterface parent_iface;


  gboolean (*handle_send_setup) (
    Iap2 *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_send_start_call_state_updates) (
    Iap2 *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_send_stop_call_state_updates) (
    Iap2 *object,
    GDBusMethodInvocation *invocation);

  void (*handle_call_state_update) (
    Iap2 *object);

};

GType iap2_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *iap2_interface_info (void);
guint iap2_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void iap2_complete_send_start_call_state_updates (
    Iap2 *object,
    GDBusMethodInvocation *invocation);

void iap2_complete_send_stop_call_state_updates (
    Iap2 *object,
    GDBusMethodInvocation *invocation);

void iap2_complete_send_setup (
    Iap2 *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void iap2_emit_handle_call_state_update (
    Iap2 *object);



/* D-Bus method calls: */
void iap2_call_send_start_call_state_updates (
    Iap2 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean iap2_call_send_start_call_state_updates_finish (
    Iap2 *proxy,
    GAsyncResult *res,
    GError **error);

gboolean iap2_call_send_start_call_state_updates_sync (
    Iap2 *proxy,
    GCancellable *cancellable,
    GError **error);

void iap2_call_send_stop_call_state_updates (
    Iap2 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean iap2_call_send_stop_call_state_updates_finish (
    Iap2 *proxy,
    GAsyncResult *res,
    GError **error);

gboolean iap2_call_send_stop_call_state_updates_sync (
    Iap2 *proxy,
    GCancellable *cancellable,
    GError **error);

void iap2_call_send_setup (
    Iap2 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean iap2_call_send_setup_finish (
    Iap2 *proxy,
    GAsyncResult *res,
    GError **error);

gboolean iap2_call_send_setup_sync (
    Iap2 *proxy,
    GCancellable *cancellable,
    GError **error);



/* ---- */

#define TYPE_IAP2_PROXY (iap2_proxy_get_type ())
#define IAP2_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_IAP2_PROXY, Iap2Proxy))
#define IAP2_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_IAP2_PROXY, Iap2ProxyClass))
#define IAP2_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_IAP2_PROXY, Iap2ProxyClass))
#define IS_IAP2_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_IAP2_PROXY))
#define IS_IAP2_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_IAP2_PROXY))

typedef struct _Iap2Proxy Iap2Proxy;
typedef struct _Iap2ProxyClass Iap2ProxyClass;
typedef struct _Iap2ProxyPrivate Iap2ProxyPrivate;

struct _Iap2Proxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  Iap2ProxyPrivate *priv;
};

struct _Iap2ProxyClass
{
  GDBusProxyClass parent_class;
};

GType iap2_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Iap2Proxy, g_object_unref)
#endif

void iap2_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Iap2 *iap2_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
Iap2 *iap2_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void iap2_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Iap2 *iap2_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
Iap2 *iap2_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_IAP2_SKELETON (iap2_skeleton_get_type ())
#define IAP2_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_IAP2_SKELETON, Iap2Skeleton))
#define IAP2_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_IAP2_SKELETON, Iap2SkeletonClass))
#define IAP2_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_IAP2_SKELETON, Iap2SkeletonClass))
#define IS_IAP2_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_IAP2_SKELETON))
#define IS_IAP2_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_IAP2_SKELETON))

typedef struct _Iap2Skeleton Iap2Skeleton;
typedef struct _Iap2SkeletonClass Iap2SkeletonClass;
typedef struct _Iap2SkeletonPrivate Iap2SkeletonPrivate;

struct _Iap2Skeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  Iap2SkeletonPrivate *priv;
};

struct _Iap2SkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType iap2_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Iap2Skeleton, g_object_unref)
#endif

Iap2 *iap2_skeleton_new (void);


G_END_DECLS

#endif /* __GDBUSCARPLAY_H__ */
